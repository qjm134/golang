/*
53. 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。


示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

示例 2：
输入：nums = [1]
输出：1

示例 3：
输入：nums = [0]
输出：0

示例 4：
输入：nums = [-1]
输出：-1

示例 5：
输入：nums = [-100000]
输出：-100000


提示：
1 <= nums.length <= 3 * 104
-105 <= nums[i] <= 105

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。


思路：
暴力：子序列，有开始，有结束。
     数组中的每个元素，可以做开始，元素后的每个元素做结束，遍历所有的子序列，计算和，然后找一个和最大

优化：
遍历每个元素做开始的时候，需要去后面找
反过来，遍历到当前元素，也是前面遍历过的元素的后面
不遍历所有元素做开始，所有元素也是结束，遍历的时候，把当前元素做结束
[2,1,-3,4]
遍历到-3的时候，开始可以是前面所有的元素，[2,1,-3]，[1,-3]，[-3]
-3做结束的时候，所有可能的和：[2,1]+(-3)，[1]+(-3)，-3
-3前面的最大和，加上-3，即是最大和
（正数可能会使和变大，负数做结束的时候，可以直接跳过，不用计算和也不用比较了，不行，还是要计算和，可能构成后面正数的和的部分）
如果最大和是负的
[2,1,-4,5]
-4使得前面最大和减少了，到5的时候，[2,1,-4,5]，[1,-4,5]，[-4,5]，[5]
[2,1,-4]+5，[1,-4]+5，[-4]+5
-4如果使得前面最大和是负数了，那4再加前面的负数，肯定最后和要小
那不如不要前面的了，重启炉灶，4作为开始了
4后面的结束的，都要从4做为开始，不能从头做开始了，从头开始的最大和都是负数了

总结：
遍历当前元素作为子序列的结束
当前元素 + 前一个元素作为结束的最大和  即为当前元素作为结束的最大和
前一个最大和如果小于0了，那当前元素最大和，如上公式2部分相加得到，就不需要加前一个元素的最大和了
*/
package maxSumInSub

func findMax(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	max := nums[0]
	preMax := 0

	for i := 0; i < len(nums); i++ {
		curMax := nums[i]
		if preMax > 0 {
			curMax = nums[i] + preMax
		}

		if curMax > max {
			max = curMax
		}

		preMax = curMax
	}
	return max
}

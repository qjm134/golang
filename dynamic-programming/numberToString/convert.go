/*
剑指 Offer 46. 把数字翻译成字符串
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。



示例 1:

输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"


提示：

0 <= num < 2的31次

思路：
可以翻译的只能是一个字符，或2个字符
第一个字符单独，剩下的字符可以组成的种数f(n-1)，这种情况种数：单独是否在1-26之间，是，则1*f(n-1)，否，0*f(n-1)
第一个跟后一个字符一起，剩下的字符可以组成的种数f(n-2)，这种情况种数：2个字符一起是否在1-26之间，是，则1*f(n-1)，否，0*f(n-2)
总数：1/0 * f(n-1) + 1/0 * f(n-2)

递归从上至下，需要保存前面计算过的，避免重复计算

那反过来，先从一个字符算起，后面不断加字符
将递归转循环，从下往上累就不用保存
f(1)=1
f(2)=f(1) + 1/0*f(0)
f(3)=f(2) + 1/0*f(1)
f(4)=f(3) + 1/0*f(2)
*/

package numberToString

func translateNum(num int) int {
	nums := make([]int, 0)

	for num != 0 {
		nums = append(nums, num%10)
		num = num / 10
	}

	l := len(nums)
	if l == 0 {
		return 0
	}
	if l == 1 {
		return 1
	}
	a := 1
	b := 1
	count := 0
	for i := l - 2; i >= 0; i-- {
		if (nums[i+1]*10+nums[i] < 26) && (nums[i+1]*10+nums[i] > 9) {
			count = b + a
		} else {
			count = b
		}
		a = b
		b = count
	}
	return count
}
